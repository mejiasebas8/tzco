<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Flower Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #FFFFFF;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        
        #canvas-container {
            width: 605px;
            height: 605px;
            background-color: #FFFFFF;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            width: 605px;
            height: 605px;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="particle-canvas"></canvas>
    </div>

    <script>
        // Particle Flower Visualization
        // Themes: feminine creative force, eternal fertility, root energy
        
        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d');
        
        const width = canvas.width = 605;
        const height = canvas.height = 605;
        const centerX = width / 2;
        const centerY = height / 2;
        
        const PARTICLE_COUNT = 30000;
        const FORM_SCALE = 2.4;
        const particles = [];
        let time = 0;
        let animationFrameId = null;
        
        // Initialize particles
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const theta = Math.random() * Math.PI * 2;
            const r = Math.pow(Math.random(), 0.5) * FORM_SCALE * 0.5 * 150;
            const height = (Math.random() * 2 - 1) * FORM_SCALE * 0.3;
            
            const angle = theta;
            const dist = r / 150;
            const flow = Math.sin(angle * 2 + height * 2) * 0.03;
            const counterFlow = Math.cos(angle * 2 - height * 2) * 0.03;
            const blend = (Math.sin(height * Math.PI) + 1) * 0.5;
            const combinedFlow = flow * blend + counterFlow * (1 - blend);
            
            const dx = r * Math.cos(theta);
            const dy = r * Math.sin(theta);
            const containment = Math.pow(Math.min(1, dist / (FORM_SCALE * 0.8)), 4);
            const pull = containment * 0.1;
            
            particles.push({
                x: centerX + dx + (dx * combinedFlow) - (dx * pull),
                y: centerY + dy + (dy * combinedFlow) - (dy * pull),
                z: height,
                initialR: r,
                initialTheta: theta,
                initialHeight: height
            });
        }
        
        // Animation timing control
        let lastFrameTime = 0;
        const targetFPS = 10;
        const frameInterval = 1000 / targetFPS;
        
        function animate(currentTime) {
            if (!lastFrameTime) {
                lastFrameTime = currentTime;
            }
            
            const deltaTime = currentTime - lastFrameTime;
            
            if (deltaTime >= frameInterval) {
                time += 0.000475;
                
                // Clear with white background and slight trails
                ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.fillRect(0, 0, width, height);
                
                particles.forEach(particle => {
                    const dx = particle.x - centerX;
                    const dy = particle.y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy) / 150;
                    const angle = Math.atan2(dy, dx);
                    const height = particle.z / (FORM_SCALE * 0.4);
                    
                    const flow = Math.sin(angle * 2 - time * 0.5 + height * 2) * 0.015;
                    const counterFlow = Math.cos(angle * 2 + time * 0.5 - height * 2) * 0.015;
                    
                    const blend = (Math.sin(height * Math.PI) + 1) * 0.5;
                    const combinedFlow = flow * blend + counterFlow * (1 - blend);
                    
                    const containment = Math.pow(Math.min(1, dist / (FORM_SCALE * 0.8)), 4);
                    const pull = containment * 0.1;
                    
                    particle.x = particle.x + (dx * combinedFlow) - (dx * pull);
                    particle.y = particle.y + (dy * combinedFlow) - (dy * pull);
                    particle.z = particle.z + Math.sin(time * 0.15 + dist * 2) * 0.01;
                    
                    const depthFactor = 1 + particle.z * 0.5;
                    const opacity = 0.35 * depthFactor;
                    const size = Math.max(0.001, 0.6 * depthFactor);
                    
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(51, 51, 51, ${opacity})`;
                    ctx.fill();
                });
                
                lastFrameTime = currentTime - (deltaTime % frameInterval);
            }
            
            animationFrameId = requestAnimationFrame(animate);
        }
        
        // Start animation
        animationFrameId = requestAnimationFrame(animate);
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        });
    </script>
</body>
</html>